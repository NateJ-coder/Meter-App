<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fuzio Meter Reading</title>
  <link rel="stylesheet" href="assets/styles.css">
</head>
<body class="reader-body">

<!-- Branded Header -->
<header class="reader-header">
  <div class="reader-header-content">
    <img src="assets/images/Fuzio logo.jpg" alt="Fuzio Properties" class="reader-logo">
    <div>
      <h1>Meter Reading</h1>
      <p class="subtitle">Fuzio Properties â€“ Official Meter Capture</p>
    </div>
  </div>
</header>

<main class="container reader-container">
  <!-- On-Site Mode Container -->
  <div id="onsite-container"></div>

  <!-- Fallback: Traditional Reader (if on-site mode not activated) -->
  <div id="traditional-reader" style="display:none;">
    <div id="context-card" class="card reader-context-card">
      <p id="context-info" class="context-text"></p>
      <div id="progress-info" class="reader-progress"></div>
    </div>

    <section class="card instructions-card">
      <h3>ðŸ“‹ What to do</h3>
      <ol>
        <li>Confirm the meter number matches the one shown above</li>
        <li>Read the number displayed on the meter</li>
        <li>Take a clear photo of the meter display</li>
        <li>Enter the reading below</li>
        <li>Tap <strong>Submit</strong> to continue</li>
      </ol>
      <p class="instruction-tip">
        ðŸ’¡ <strong>Tip:</strong> If the meter is inaccessible, damaged, or unclear, make a note in the "Notes" field.
      </p>
    </section>

    <section class="card">
      <form id="reader-form">
        <div class="form-group">
          <label for="reading-value">Current Reading (kWh) *</label>
          <input 
            type="number" 
            id="reading-value" 
            required 
            step="0.01"
            inputmode="decimal"
            class="reader-input-large"
            placeholder="Enter meter reading..."
          >
          <div id="reading-feedback" class="input-feedback"></div>
        </div>

        <div class="form-group">
          <label for="photo-ref">Meter Photo Reference *</label>
          <input 
            type="text" 
            id="photo-ref" 
            placeholder="Photo filename or description" 
            required
            class="reader-input"
          >
        </div>

        <div class="form-group">
          <label for="notes">Notes (optional)</label>
          <textarea id="notes" rows="2" placeholder="Any observations or issues..."></textarea>
        </div>

        <button type="submit" class="btn btn-primary btn-large reader-submit">
          Submit & Continue
        </button>
      </form>
    </section>
  </div>

  <!-- Error Message -->
  <section id="error-message" class="card error-card" style="display:none;">
    <div class="error-icon">âš </div>
    <h2>Unable to load meter</h2>
    <p id="error-text"></p>
    <div class="info-box">
      <strong>Note:</strong> This app uses localStorage (browser storage). 
      Make sure you're accessing from the same device/browser where meters were created.
    </div>
    <a href="index.html" class="btn btn-secondary mt-2">Return to Dashboard</a>
  </section>

  <!-- Success Message -->
  <section id="success-message" class="card success-card" style="display:none;">
    <div class="completion-icon">âœ“</div>
    <h2>All Readings Captured!</h2>
    <p>Thank you. All meter readings have been submitted successfully.</p>
    <a href="index.html" class="btn btn-primary btn-large mt-2">Return to Dashboard</a>
  </section>
</main>

<script type="module">
  import { storage } from './assets/storage.js';
  import { validation } from './assets/validation.js';
  import { onSiteMode } from './assets/on-site-mode.js';
  import { getCurrentDateTime } from './assets/app.js';

  // Make globally available
  window.storage = storage;
  window.onSiteMode = onSiteMode;

  // Get URL params
  const params = new URLSearchParams(window.location.search);
  const schemeId = params.get('scheme_id');
  const currentIndex = parseInt(params.get('index') || '0');
  const mode = params.get('mode'); // 'onsite' for on-site mode

  let workflowContext = null;

  // Check if we should use on-site mode
  if (mode === 'onsite' || onSiteMode.isActive()) {
    initializeOnsiteMode();
  } else {
    initializeTraditionalReader();
  }

  function initializeOnsiteMode() {
    console.log('Initializing On-Site Mode...');
    
    // Activate on-site mode
    onSiteMode.activate();

    // Find open cycle
    const cycles = storage.getAll('cycles');
    const openCycle = cycles.find(c => c.status === 'OPEN');

    if (!openCycle) {
      showError('No open reading cycle found. Please open a cycle first.');
      return;
    }

    // Render on-site capture
    document.getElementById('traditional-reader').style.display = 'none';
    onSiteMode.renderOnSiteCapture('onsite-container', openCycle.id);
  }

  function initializeTraditionalReader() {
    console.log('Initializing Traditional Reader...');
    document.getElementById('traditional-reader').style.display = 'block';
    workflowContext = loadWorkflowContext();
    
    if (workflowContext) {
      displayMeterContext(workflowContext);
      setupFormHandlers();
    }
  }

  // --- Load workflow context ---
  function loadWorkflowContext() {
    // Starting from bulk meter QR scan
    if (schemeId && currentIndex === 0) {
      const scheme = storage.get('schemes', schemeId);
      if (!scheme) {
        showError(`Scheme not found (ID: ${schemeId}). Please ensure you're on the same device/browser where the scheme was created.`);
        return null;
      }

      // Find bulk meter for this scheme
      const bulkMeter = storage.getAll('meters').find(m => 
        m.meter_type === 'BULK' && m.scheme_id === schemeId
      );

      if (!bulkMeter) {
        showError('No bulk meter found for this scheme. Please contact the managing agent.');
        return null;
      }
      
      // Check open cycle
      const openCycle = storage.getOpenCycle(schemeId);
      if (!openCycle) {
        showError('No reading cycle is currently open. The admin must open a new cycle before readings can be captured.');
        return null;
      }

      // Get all submeters for this scheme (across all buildings)
      const buildings = storage.getBuildings(schemeId);
      const allUnits = [];
      buildings.forEach(building => {
        const units = storage.getUnits(building.id);
        units.forEach(unit => {
          allUnits.push({ ...unit, building_id: building.id, building_name: building.name });
        });
      });
      
      const unitIds = allUnits.map(u => u.id);
      const submeters = storage.getAll('meters')
        .filter(m => m.meter_type === 'UNIT' && unitIds.includes(m.unit_id))
        .map(meter => {
          const unit = allUnits.find(u => u.id === meter.unit_id);
          return { ...meter, unit_info: unit };
        })
        .sort((a, b) => {
          // Sort by building name, then unit number
          if (a.unit_info.building_name !== b.unit_info.building_name) {
            return a.unit_info.building_name.localeCompare(b.unit_info.building_name);
          }
          return a.unit_info.unit_number.localeCompare(b.unit_info.unit_number, undefined, { numeric: true });
        });

      return {
        scheme,
        bulkMeter,
        openCycle,
        submeters,
        currentIndex: 0,
        currentMeter: bulkMeter,
        totalMeters: submeters.length + 1 // bulk + all submeters
      };
    }

    // Continuing with submeters
    if (schemeId && currentIndex > 0) {
      const scheme = storage.get('schemes', schemeId);
      const openCycle = storage.getOpenCycle(schemeId);

      // Get all submeters again (same logic)
      const buildings = storage.getBuildings(schemeId);
      const allUnits = [];
      buildings.forEach(building => {
        const units = storage.getUnits(building.id);
        units.forEach(unit => {
          allUnits.push({ ...unit, building_id: building.id, building_name: building.name });
        });
      });
      
      const unitIds = allUnits.map(u => u.id);
      const submeters = storage.getAll('meters')
        .filter(m => m.meter_type === 'UNIT' && unitIds.includes(m.unit_id))
        .map(meter => {
          const unit = allUnits.find(u => u.id === meter.unit_id);
          return { ...meter, unit_info: unit };
        })
        .sort((a, b) => {
          if (a.unit_info.building_name !== b.unit_info.building_name) {
            return a.unit_info.building_name.localeCompare(b.unit_info.building_name);
          }
          return a.unit_info.unit_number.localeCompare(b.unit_info.unit_number, undefined, { numeric: true });
        });

      // Determine which submeter we're on (index 1 = first submeter, 2 = second, etc.)
      const submeterIndex = currentIndex - 1;
      if (submeterIndex >= submeters.length) {
        // All done!
        showSuccess();
        return null;
      }

      const currentMeter = submeters[submeterIndex];

      return {
        scheme,
        bulkMeter: null,
        openCycle,
        submeters,
        currentIndex,
        currentMeter,
        totalMeters: submeters.length + 1
      };
    }

    showError('Invalid QR code. Please scan a scheme bulk meter QR code to start.');
    return null;
  }

  // --- Display current meter context ---
  function displayMeterContext(context) {
    const meter = context.currentMeter;
    
    let contextText = `${context.scheme.name}`;
    let progressText = '';
    
    if (context.currentIndex === 0) {
      // Bulk meter
      contextText += ` | BULK METER: ${meter.meter_number}`;
      progressText = `Step 1 of ${context.totalMeters}: Bulk Meter`;
      document.getElementById('progress-info').className = 'reader-progress bulk';
    } else {
      // Submeter
      contextText += ` - ${meter.unit_info.building_name} - Unit ${meter.unit_info.unit_number}`;
      progressText = `Meter ${context.currentIndex + 1} of ${context.totalMeters}`;
      document.getElementById('progress-info').className = 'reader-progress unit';
      
      // Add last reading info
      if (meter.last_reading) {
        contextText += ` | Meter: ${meter.meter_number} | Last: ${meter.last_reading} kWh`;
      } else {
        contextText += ` | Meter: ${meter.meter_number}`;
      }
    }

    document.getElementById('context-info').textContent = contextText;
    document.getElementById('progress-info').textContent = progressText;
    document.getElementById('context-card').style.display = 'block';
  }

  // --- Setup form handlers ---
  function setupFormHandlers() {
    const meter = workflowContext.currentMeter;
    
    // Real-time validation feedback
    const readingInput = document.getElementById('reading-value');
    const feedbackDiv = document.getElementById('reading-feedback');
    
    readingInput.addEventListener('input', function() {
      const value = parseFloat(this.value);
      
      if (isNaN(value) || value === 0) {
        feedbackDiv.textContent = '';
        return;
      }
      
      if (meter.last_reading) {
        const consumption = value - meter.last_reading;
        
        if (consumption < 0) {
          feedbackDiv.textContent = `âš  Reading is lower than last reading (${meter.last_reading} kWh)`;
          feedbackDiv.className = 'input-feedback warning';
        } else if (consumption === 0) {
          feedbackDiv.textContent = `â„¹ No consumption since last reading`;
          feedbackDiv.className = 'input-feedback info';
        } else {
          feedbackDiv.textContent = `âœ“ Consumption: ${consumption.toFixed(2)} kWh`;
          feedbackDiv.className = 'input-feedback success';
        }
      } else {
        feedbackDiv.textContent = `â„¹ First reading for this meter`;
        feedbackDiv.className = 'input-feedback info';
      }
    });

    // Handle form submission
    document.getElementById('reader-form').addEventListener('submit', function (e) {
      e.preventDefault();

      const readingValue = parseFloat(document.getElementById('reading-value').value);
      const photoRef = document.getElementById('photo-ref').value;
      const notes = document.getElementById('notes').value;

      // Calculate consumption
      const consumption = validation.calculateConsumption(readingValue, meter.last_reading);

      // Create reading record
      const readingData = {
        meter_id: meter.id,
        cycle_id: workflowContext.openCycle.id,
        reading_value: readingValue,
        reading_date: getCurrentDateTime(),
        photo: photoRef,
        notes: notes,
        consumption: consumption,
        captured_by: 'QR Reader',
        flags: [],
        review_status: 'pending'
      };

      // Validate and generate flags
      readingData.flags = validation.validateReading(readingData);

      // Save to readings
      storage.create('readings', readingData);

      // Update meter's last reading
      storage.update('meters', meter.id, { last_reading: readingValue });

      // Move to next meter or finish
      const nextIndex = workflowContext.currentIndex + 1;
      
      if (nextIndex < workflowContext.totalMeters) {
        // Continue to next submeter
        const nextUrl = `reader.html?scheme_id=${workflowContext.scheme.id}&index=${nextIndex}`;
        window.location.href = nextUrl;
      } else {
        // All done!
        showSuccess();
      }
    });
  }

  function showError(message) {
    document.getElementById('error-text').textContent = message;
    document.getElementById('traditional-reader').style.display = 'none';
    document.getElementById('error-message').style.display = 'block';
  }

  function showSuccess() {
    document.getElementById('traditional-reader').style.display = 'none';
    document.getElementById('success-message').style.display = 'block';
  }
</script>

</body>
</html>
