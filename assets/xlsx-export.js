/**
 * xlsx-export.js - Excel Export with SheetJS
 * Creates professional XLSX reports for meter readings
 */

import { storage } from './storage.js';
import { auth } from './auth.js';

export const xlsxExport = {
    /**
     * Generate individual meter report for dispute pack
     * Creates a detailed single-meter report with history and photos
     */
    async exportMeterReport(meterId, cycleId) {
        const meter = storage.getMeterWithDetails(meterId);
        const cycle = storage.get('cycles', cycleId);
        const scheme = storage.get('schemes', cycle.scheme_id);
        const reading = storage.getReadings(cycleId).find(r => r.meter_id === meterId);
        
        if (!reading) {
            alert('No reading found for this meter in the selected cycle.');
            return;
        }

        // Load SheetJS library if not already loaded
        await this.loadSheetJS();

        const wb = XLSX.utils.book_new();

        // Sheet 1: Meter Details & Current Reading
        const summaryData = [
            ['FUZIO PROPERTIES - METER READING REPORT'],
            [''],
            ['Report Generated:', new Date().toLocaleString()],
            ['Generated By:', auth.getCurrentUser()?.name || 'System'],
            [''],
            ['=== PROPERTY DETAILS ==='],
            ['Scheme:', scheme.name],
            ['Building:', meter.building_name || 'N/A'],
            ['Unit Number:', meter.unit_name || 'N/A'],
            [''],
            ['=== METER DETAILS ==='],
            ['Meter Number:', meter.meter_number],
            ['Meter Type:', meter.meter_type],
            ['Meter Location:', meter.meter_location || 'N/A'],
            ['Installation Date:', meter.installation_date || 'N/A'],
            [''],
            ['=== CURRENT READING DETAILS ==='],
            ['Reading Period:', `${cycle.start_date} to ${cycle.end_date}`],
            ['Reading Date:', reading.reading_date],
            ['Captured By:', reading.captured_by || 'Unknown'],
            [''],
            ['PREVIOUS READING:', meter.last_reading || 0],
            ['CURRENT READING:', reading.reading_value],
            ['DIFFERENCE (Consumption):', reading.consumption != null ? reading.consumption.toFixed(2) + ' kWh' : 'N/A'],
            [''],
            ['Note:', 'Consumption = Current Reading - Previous Reading'],
            [''],
            ['Reading Method:', reading.captured_by?.includes('QR') ? 'QR Code' : 'Manual Entry'],
            [''],
            ['=== FLAGS & ISSUES ==='],
        ];

        if (reading.flags && reading.flags.length > 0) {
            reading.flags.forEach((flag, idx) => {
                summaryData.push([`Flag ${idx + 1}:`, flag.type]);
                summaryData.push(['Description:', flag.description || 'N/A']);
            });
        } else {
            summaryData.push(['Status:', 'No issues detected']);
        }

        summaryData.push(['']);
        summaryData.push(['=== REVIEW STATUS ===']);
        summaryData.push(['Status:', reading.review_status || 'Pending']);
        summaryData.push(['Reviewed By:', reading.reviewed_by || 'Not reviewed']);
        summaryData.push(['Review Date:', reading.review_date || 'N/A']);
        summaryData.push(['Notes:', reading.notes || 'None']);

        // Get reading history for this meter (last 6 readings)
        const allCycles = storage.getAll('cycles')
            .filter(c => c.scheme_id === scheme.id)
            .sort((a, b) => new Date(b.start_date) - new Date(a.start_date))
            .slice(0, 6);

        const historyData = [
            ['=== READING HISTORY (Last 6 Cycles) ==='],
            [''],
            ['Period', 'Reading Date', 'Previous Reading', 'Current Reading', 'Difference (kWh)', 'Flags']
        ];

        allCycles.forEach(c => {
            const historicalReading = storage.getReadings(c.id).find(r => r.meter_id === meterId);
            if (historicalReading) {
                const flags = historicalReading.flags ? historicalReading.flags.map(f => f.type).join(', ') : 'None';
                const historicalMeter = storage.get('meters', meterId);
                historyData.push([
                    `${c.start_date} to ${c.end_date}`,
                    historicalReading.reading_date,
                    historicalMeter.last_reading || 0,
                    historicalReading.reading_value,
                    historicalReading.consumption != null ? historicalReading.consumption.toFixed(2) : 'N/A',
                    flags
                ]);
            }
        });

        summaryData.push(['']);
        summaryData.push(...historyData);

        // Add photo reference if exists
        if (reading.photo) {
            summaryData.push(['']);
            summaryData.push(['=== PHOTO EVIDENCE ===']);
            summaryData.push(['Photo Captured:', 'Yes']);
            summaryData.push(['Note:', 'Photo is stored in dispute pack and can be viewed in the app']);
        }

        const ws = XLSX.utils.aoa_to_sheet(summaryData);

        // Set column widths
        ws['!cols'] = [
            { wch: 25 },
            { wch: 40 }
        ];

        XLSX.utils.book_append_sheet(wb, ws, 'Meter Report');

        // Download file
        const filename = `Meter-Report-${meter.meter_number}-${cycle.start_date}.xlsx`;
        XLSX.writeFile(wb, filename);

        return filename;
    },

    /**
     * Generate comprehensive scheme report with analytics
     * Multi-sheet workbook with summary, details, and analytics
     */
    async exportSchemeReport(cycleId) {
        const cycle = storage.get('cycles', cycleId);
        const scheme = storage.get('schemes', cycle.scheme_id);
        const readings = storage.getReadings(cycleId);
        const meters = storage.getMeters(cycle.scheme_id);
        const currentUser = auth.getCurrentUser();

        await this.loadSheetJS();

        const wb = XLSX.utils.book_new();

        // === SHEET 1: EXECUTIVE SUMMARY ===
        const summaryData = this.buildSummarySheet(cycle, scheme, readings, meters, currentUser);
        const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
        wsSummary['!cols'] = [{ wch: 30 }, { wch: 20 }];
        XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');

        // === SHEET 2: UNIT READINGS (DETAILED) ===
        const unitData = this.buildUnitReadingsSheet(cycle, scheme, readings);
        const wsUnits = XLSX.utils.aoa_to_sheet(unitData);
        wsUnits['!cols'] = [
            { wch: 15 }, // Building
            { wch: 12 }, // Unit
            { wch: 15 }, // Meter
            { wch: 12 }, // Previous
            { wch: 12 }, // Current
            { wch: 12 }, // Consumption
            { wch: 15 }, // Reading Date
            { wch: 20 }, // Captured By
            { wch: 25 }, // Flags
            { wch: 12 }  // Review Status
        ];
        XLSX.utils.book_append_sheet(wb, wsUnits, 'Unit Readings');

        // === SHEET 3: ANALYTICS ===
        const analyticsData = this.buildAnalyticsSheet(cycle, scheme, readings, meters);
        const wsAnalytics = XLSX.utils.aoa_to_sheet(analyticsData);
        wsAnalytics['!cols'] = [{ wch: 20 }, { wch: 15 }, { wch: 18 }];
        XLSX.utils.book_append_sheet(wb, wsAnalytics, 'Analytics');

        // === SHEET 4: FLAGS & ISSUES ===
        const flagsData = this.buildFlagsSheet(readings);
        const wsFlags = XLSX.utils.aoa_to_sheet(flagsData);
        wsFlags['!cols'] = [{ wch: 15 }, { wch: 12 }, { wch: 15 }, { wch: 20 }, { wch: 30 }];
        XLSX.utils.book_append_sheet(wb, wsFlags, 'Flags & Issues');

        // Download file
        const filename = `Scheme-Report-${scheme.name.replace(/\s+/g, '-')}-${cycle.start_date}.xlsx`;
        XLSX.writeFile(wb, filename);

        alert(`✅ Scheme report exported successfully!\n\nFilename: ${filename}\n\nIncludes 4 sheets:\n• Summary (bulk reconciliation)\n• Unit Readings (detailed)\n• Analytics (top consumers)\n• Flags & Issues`);

        return filename;
    },

    /**
     * Build summary sheet with bulk reconciliation
     */
    buildSummarySheet(cycle, scheme, readings, meters, currentUser) {
        // Calculate bulk reconciliation
        let bulk_kWh = 0;
        let sum_units_kWh = 0;

        const bulkMeter = meters.find(m => m.meter_type === 'BULK');
        if (bulkMeter) {
            const bulkReading = readings.find(r => r.meter_id === bulkMeter.id);
            if (bulkReading && bulkReading.consumption != null) {
                bulk_kWh = bulkReading.consumption;
            }
        }

        readings.forEach(reading => {
            const meter = storage.get('meters', reading.meter_id);
            if (meter && meter.meter_type === 'UNIT' && reading.consumption != null) {
                sum_units_kWh += reading.consumption;
            }
        });

        const common_kWh = bulk_kWh - sum_units_kWh;
        const losses_percent = bulk_kWh > 0 ? ((common_kWh / bulk_kWh) * 100) : 0;

        const unitMeters = meters.filter(m => m.meter_type === 'UNIT');
        const unitReadings = readings.filter(r => {
            const m = storage.get('meters', r.meter_id);
            return m && m.meter_type === 'UNIT';
        });
        const flaggedCount = readings.filter(r => r.flags && r.flags.length > 0).length;

        return [
            ['FUZIO PROPERTIES - SCHEME ELECTRICITY REPORT'],
            [''],
            ['Report Generated:', new Date().toLocaleString()],
            ['Generated By:', currentUser?.name || 'System'],
            ['Email:', currentUser?.email || 'N/A'],
            [''],
            ['=== SCHEME DETAILS ==='],
            ['Scheme Name:', scheme.name],
            ['Address:', scheme.address || 'N/A'],
            ['Reading Period:', `${cycle.start_date} to ${cycle.end_date}`],
            ['Cycle Status:', cycle.status],
            [''],
            ['=== BULK RECONCILIATION ==='],
            ['Bulk Meter Reading (kWh):', bulk_kWh.toFixed(2)],
            ['Sum of Unit Meters (kWh):', sum_units_kWh.toFixed(2)],
            ['Common Property Usage (kWh):', common_kWh.toFixed(2)],
            ['Loss Percentage:', losses_percent.toFixed(2) + '%'],
            [''],
            ['Explanation:', 'Common Property Usage = Bulk Meter - Sum of Units'],
            ['Note:', 'This represents common area consumption, electrical losses, or unmetered usage'],
            [''],
            ['=== READING STATISTICS ==='],
            ['Total Unit Meters:', unitMeters.length],
            ['Readings Captured:', unitReadings.length],
            ['Not Read:', unitMeters.length - unitReadings.length],
            ['Flagged Readings:', flaggedCount],
            ['Completion Rate:', `${((unitReadings.length / unitMeters.length) * 100).toFixed(1)}%`],
            [''],
            ['=== DATA QUALITY ==='],
            ['Readings with Flags:', flaggedCount],
            ['Readings Pending Review:', readings.filter(r => !r.review_status || r.review_status === 'pending').length],
            ['Readings Approved:', readings.filter(r => r.review_status === 'approved').length],
        ];
    },

    /**
     * Build unit readings sheet
     */
    buildUnitReadingsSheet(cycle, scheme, readings) {
        const data = [
            ['UNIT READINGS - DETAILED'],
            ['Scheme:', scheme.name],
            ['Period:', `${cycle.start_date} to ${cycle.end_date}`],
            [''],
            ['Building', 'Unit', 'Meter Number', 'Previous', 'Current', 'Consumption (kWh)', 'Reading Date', 'Captured By', 'Flags', 'Review Status']
        ];

        readings.forEach(reading => {
            const meter = storage.getMeterWithDetails(reading.meter_id);
            if (!meter || meter.meter_type !== 'UNIT') return;

            const flags = reading.flags ? reading.flags.map(f => f.type).join(', ') : 'None';
            const consumption = reading.consumption != null ? reading.consumption.toFixed(2) : 'N/A';

            data.push([
                meter.building_name || 'N/A',
                meter.unit_name || 'N/A',
                meter.meter_number,
                meter.last_reading || 0,
                reading.reading_value,
                consumption,
                reading.reading_date,
                reading.captured_by || 'Unknown',
                flags,
                reading.review_status || 'Pending'
            ]);
        });

        return data;
    },

    /**
     * Build analytics sheet with top consumers
     */
    buildAnalyticsSheet(cycle, scheme, readings, meters) {
        // Calculate consumption per unit
        const unitConsumption = [];

        readings.forEach(reading => {
            const meter = storage.getMeterWithDetails(reading.meter_id);
            if (!meter || meter.meter_type !== 'UNIT' || reading.consumption == null) return;

            unitConsumption.push({
                building: meter.building_name || 'N/A',
                unit: meter.unit_name || 'N/A',
                meter_number: meter.meter_number,
                consumption: reading.consumption
            });
        });

        // Sort by consumption (highest first)
        unitConsumption.sort((a, b) => b.consumption - a.consumption);

        // Calculate statistics
        const totalConsumption = unitConsumption.reduce((sum, u) => sum + u.consumption, 0);
        const avgConsumption = unitConsumption.length > 0 ? totalConsumption / unitConsumption.length : 0;
        const maxConsumption = unitConsumption.length > 0 ? unitConsumption[0].consumption : 0;
        const minConsumption = unitConsumption.length > 0 ? unitConsumption[unitConsumption.length - 1].consumption : 0;

        const data = [
            ['CONSUMPTION ANALYTICS'],
            ['Scheme:', scheme.name],
            ['Period:', `${cycle.start_date} to ${cycle.end_date}`],
            [''],
            ['=== STATISTICS ==='],
            ['Total Units:', unitConsumption.length],
            ['Total Consumption (kWh):', totalConsumption.toFixed(2)],
            ['Average Consumption (kWh):', avgConsumption.toFixed(2)],
            ['Highest Consumption (kWh):', maxConsumption.toFixed(2)],
            ['Lowest Consumption (kWh):', minConsumption.toFixed(2)],
            [''],
            ['=== TOP 10 CONSUMERS ==='],
            ['Rank', 'Unit', 'Consumption (kWh)', '% of Total']
        ];

        unitConsumption.slice(0, 10).forEach((unit, index) => {
            const percentage = totalConsumption > 0 ? (unit.consumption / totalConsumption * 100).toFixed(1) : 0;
            data.push([
                index + 1,
                `${unit.building} - ${unit.unit}`,
                unit.consumption.toFixed(2),
                percentage + '%'
            ]);
        });

        data.push(['']);
        data.push(['=== CONSUMPTION DISTRIBUTION ===']);
        
        // Group units into consumption ranges
        const ranges = [
            { label: '0-100 kWh', min: 0, max: 100, count: 0 },
            { label: '101-200 kWh', min: 101, max: 200, count: 0 },
            { label: '201-300 kWh', min: 201, max: 300, count: 0 },
            { label: '301-500 kWh', min: 301, max: 500, count: 0 },
            { label: '500+ kWh', min: 501, max: Infinity, count: 0 }
        ];

        unitConsumption.forEach(unit => {
            const range = ranges.find(r => unit.consumption >= r.min && unit.consumption <= r.max);
            if (range) range.count++;
        });

        data.push(['Range', 'Number of Units', 'Percentage']);
        ranges.forEach(range => {
            const percentage = unitConsumption.length > 0 ? (range.count / unitConsumption.length * 100).toFixed(1) : 0;
            data.push([range.label, range.count, percentage + '%']);
        });

        return data;
    },

    /**
     * Build flags and issues sheet
     */
    buildFlagsSheet(readings) {
        const data = [
            ['FLAGS & ISSUES REPORT'],
            [''],
            ['Building', 'Unit', 'Meter Number', 'Flag Type', 'Description']
        ];

        let flagCount = 0;
        readings.forEach(reading => {
            if (reading.flags && reading.flags.length > 0) {
                const meter = storage.getMeterWithDetails(reading.meter_id);
                reading.flags.forEach(flag => {
                    data.push([
                        meter?.building_name || 'N/A',
                        meter?.unit_name || 'N/A',
                        meter?.meter_number || 'N/A',
                        flag.type,
                        flag.description || 'No description'
                    ]);
                    flagCount++;
                });
            }
        });

        if (flagCount === 0) {
            data.push(['No flags or issues detected', '', '', '', '']);
        }

        return data;
    },

    /**     * Generate dispute pack report from pre-assembled dispute pack data
     * Used on dispute.html page
     */
    async exportDisputePackReport(disputePack) {
        await this.loadSheetJS();

        const wb = XLSX.utils.book_new();

        // === SHEET 1: DISPUTE PACK SUMMARY ===
        const summaryData = [
            ['FUZIO PROPERTIES - DISPUTE PACK'],
            ['Meter Reading History & Evidence'],
            [''],
            ['Generated:', new Date().toLocaleString()],
            ['Generated By:', auth.getCurrentUser()?.name || 'System'],
            [''],
            ['=== PROPERTY DETAILS ==='],
            ['Scheme:', disputePack.scheme.name],
            ['Address:', disputePack.scheme.address || 'N/A'],
            ['Building:', disputePack.building.name],
            ['Unit:', disputePack.unit.unit_number],
            ['Owner:', disputePack.unit.owner_name || 'N/A'],
            [''],
            ['=== METER DETAILS ==='],
            ['Meter Number:', disputePack.meter?.meter_number || 'N/A'],
            ['Meter Type:', disputePack.meter?.meter_type || 'N/A'],
            ['Meter Status:', disputePack.meter?.status || 'N/A'],
            [''],
            ['=== CONSUMPTION SUMMARY ==='],
            ['Total Cycles:', disputePack.summary.total_cycles],
            ['Total Consumption (kWh):', disputePack.summary.total_consumption.toFixed(2)],
            ['Average Consumption (kWh):', disputePack.summary.average_consumption.toFixed(2)],
            ['Flagged Cycles:', disputePack.summary.flagged_cycles_count],
            ['Estimated Readings:', disputePack.summary.estimated_cycles_count],
            ['Missing Readings:', disputePack.summary.missing_readings_count || 0],
            [''],
            ['=== DATA QUALITY ==='],
            ['Completion Rate:', disputePack.summary.missing_readings_count === 0 ? '100%' : `${((1 - disputePack.summary.missing_readings_count / disputePack.summary.total_cycles) * 100).toFixed(1)}%`],
            ['Data Quality:', disputePack.summary.flagged_cycles_count === 0 ? 'Good' : 'Has Issues'],
        ];

        const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
        wsSummary['!cols'] = [{ wch: 30 }, { wch: 25 }];
        XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');

        // === SHEET 2: READING HISTORY ===
        const historyData = [
            ['READING HISTORY - LAST 6 CYCLES'],
            [''],
            ['Period Start', 'Period End', 'Status', 'Previous Reading', 'Current Reading', 'Consumption (kWh)', 'Reading Date', 'Captured By', 'Flags', 'Review Status', 'Has Photo']
        ];

        disputePack.cycles.forEach(cycle => {
            const reading = cycle.reading;
            
            if (reading.missing) {
                historyData.push([
                    cycle.period.start_date,
                    cycle.period.end_date,
                    cycle.cycle_status,
                    'MISSING',
                    'MISSING',
                    'MISSING',
                    'N/A',
                    'N/A',
                    'Missing Reading',
                    'N/A',
                    'No'
                ]);
            } else {
                const flags = cycle.flags.length > 0 ? cycle.flags.map(f => f.type).join(', ') : 'None';
                const reviewStatus = cycle.review ? cycle.review.status : 'Not Reviewed';
                const hasPhoto = cycle.data_quality.has_photo ? 'Yes' : 'No';

                historyData.push([
                    cycle.period.start_date,
                    cycle.period.end_date,
                    cycle.cycle_status,
                    reading.previous !== null ? reading.previous.toFixed(2) : 'N/A',
                    reading.current !== null ? reading.current.toFixed(2) : 'N/A',
                    reading.consumption !== null ? reading.consumption.toFixed(2) : 'N/A',
                    reading.reading_date || 'N/A',
                    reading.captured_by || 'Unknown',
                    flags,
                    reviewStatus,
                    hasPhoto
                ]);
            }
        });

        const wsHistory = XLSX.utils.aoa_to_sheet(historyData);
        wsHistory['!cols'] = [
            { wch: 12 }, { wch: 12 }, { wch: 10 }, { wch: 15 },
            { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 20 },
            { wch: 20 }, { wch: 15 }, { wch: 10 }
        ];
        XLSX.utils.book_append_sheet(wb, wsHistory, 'Reading History');

        // === SHEET 3: FLAGS & ISSUES ===
        const flagsData = [
            ['FLAGS & ISSUES REPORT'],
            [''],
            ['Period', 'Flag Type', 'Description', 'Review Status']
        ];

        let hasFlags = false;
        disputePack.cycles.forEach(cycle => {
            if (cycle.flags.length > 0) {
                cycle.flags.forEach(flag => {
                    flagsData.push([
                        `${cycle.period.start_date} to ${cycle.period.end_date}`,
                        flag.type,
                        flag.message || 'No description',
                        cycle.review ? cycle.review.status : 'Not Reviewed'
                    ]);
                    hasFlags = true;
                });
            }
        });

        if (!hasFlags) {
            flagsData.push(['No flags or issues detected', '', '', '']);
        }

        const wsFlags = XLSX.utils.aoa_to_sheet(flagsData);
        wsFlags['!cols'] = [{ wch: 25 }, { wch: 20 }, { wch: 40 }, { wch: 15 }];
        XLSX.utils.book_append_sheet(wb, wsFlags, 'Flags & Issues');

        // Download file
        const filename = `Dispute-Pack-${disputePack.unit.unit_number}-${Date.now()}.xlsx`;
        XLSX.writeFile(wb, filename);

        alert(`✅ Dispute pack exported!\n\nFilename: ${filename}\n\nIncludes:\n• Summary (unit & consumption details)\n• Reading History (last 6 cycles)\n• Flags & Issues (all problems detected)`);

        return filename;
    },

    /**     * Load SheetJS library from CDN
     */
    async loadSheetJS() {
        if (typeof XLSX !== 'undefined') {
            return; // Already loaded
        }

        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
};
